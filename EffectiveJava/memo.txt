item 49
 - 매개 변수는 항상 함수 몸체 시작 전에 유효한지 체크! (오류를 즉시 잡지 못하면 해당 오류 탐지 및 발생 지점 찾기가 어려워짐)
 - public, protected 메소드는 매개 변수 값이 잘못됐을 때 던지는 예외를 문서화해야 함
 - requireNonNull, assert 등 활용 가능
 - 나중에 쓰기 위해 저장하는 매개변수들은 특히 더 신경써서 검사 (feat. 생성자)
 - 유효성 검사 비용이 지나치게 높거나 계산 과정에서 암묵적으로 검사가 수행될 때는 몸체 실행 전 검사 예외
    - ex) Collections.sort(List)
    - 그렇다고 암묵적 유효성 검사에 너무 의존하면 실패 원자성을 해칠 수 있으니 유의

item 50
 - 항상 java로 설계할 땐 클라이언트가 불변식을 깨뜨릴려고 혈안이 돼 있다 가정하고 방어적으로 설계해야 함
    - 외부로부터 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 함
    - 그 방어적 복사는 항상 유효성 검사 전에!
 - 방어적 복사를 생략할 땐 -> 클래스와 클라이언트 간 상호 신뢰가 보장될 때 혹은 불변식이 깨지더라도 그 영향이 클라이언트로 국한될 때만!

item 51
 - 메소드 이름은 신중히 짓기(표준 명명 규칙 따르기)
 - 편의 메소드를 너무 많이 만들지 말기
    - 메소드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지 보수하기가 어려움
 - 매개 변수 목록은 짧게 유지(한 4개 이하로)
    - 같은 타입의 매개 변수가 여러 개 연달아 나올 때가 특히 해로움
    1) 여러 메소드로 쪼개기
    2) 매개변수 여러 개를 묶어주는 도우미 클래스 생성(주로 정적 멤버 클래스로 둠)
    3) 빌더 패턴 응용(매개변수가 많은데 그 중 일부는 생략해도 괜찮을 때 유용)
 - 매개 변수 타입으로는 인터페이스가 좋음
    ex) HashMap 보다는 Map이 범용성, 확장성 면에서 훨씬 유리
 - boolean 보다는 원소 2개짜리 열거 타입으로

 AudioAttributes audioAttributes = new AudioAttributes.Builder()
                 .setLegacyStreamType(STREAM_TYPE)
                 .build();

             AudioFormat audioFormat = new AudioFormat.Builder()
                 .setSampleRate(SAMPLE_RATE)
                 .setEncoding(AUDIO_FORMAT)
                 .setChannelMask(CHANNEL_TYPE)
                 .build();

             audioTracker = new AudioTrack(audioAttributes, audioFormat, BUFFER_SIZE, MODE_STREAM, 0);

item 52
 - 재정의한 메소드는 동적으로 선택되고 다중정의한 메소드는 정적으로 선택됨
    - 다중정의가 혼동을 일으키는 상황은 최대한 피해야 함 -> 매개변수 수가 같은 다중정의는 만들지 말기(차라리 메소드 이름을 다르게 짓던가)
    - ex) ObjectOutputStream의 writeBoolean, writeInt, writeLong...
 - 메소드를 다중정의할 때 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아선 안됨

item 53
 - 성능에 민감한 상황이라면 가변인수가 걸림돌이 될 수 있음
    - 대부분 많이 쓰이는 메소드를 다중 정의해 놓고 그 외 나머지를 가변 인수로 놓으면 성능에 도움이 될 수 있음

item 54
 - 배열을 쓰든 List를 쓰든 어떠한 컬렉션을 쓰더라도 빈 배열 또는 컬렉션을 반환하기! null 반환하지 말자!

item 55
 - Optional을 반환하는 메소드에서는 절대 null 반환 금지! (애초에 null 반환 막을라고 Optional 도입했는데..)
    - 검사 예외와 취지가 비슷(반환값이 없을 수도 있음을 사용자에게 명확히 전달)
 - 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안됨
    - 단지 결과가 없을 수 있으며, 클라이언트가 이 상황을 특별히 처리해야 될 때 Optional<T> 반환해야 함
    - 하지만 역시 성능이 중요한 상황에서는 이러한 옵셔널도 쓸 필요가 있는지 세심히 주의를 기울여야..
 - 박싱된 기본 타입을 담은 옵셔널을 반환하지는 말자 (OptionalInt, OptionalLong.. 등이 있음)
 - 옵셔널을 컬렉션의 키, 값, 원소로 사용하는 것이 적절하지는 않음
